# rtl_gen
## 流程
1. 读取参数
2. 读取计算图和权重
3. 根据计算图推算im2col后矩阵尺寸
4. 根据矩阵尺寸及片上资源分析bram和lut的使用
5. 根据资源分配结果切分矩阵
6. 生成张量表达式，详细描述计算流程
7. 生成代码
















## 关于张量表达式的生成和资源自动分配

### 首先根据计算图计算各层卷积大小
根据计算图中的数据，计算使用im2col后，各层卷积转换的矩阵大小
由于矩阵边长的限制，分块后单个矩阵的最大边长是有限的，
比如resnet18中，所需要计算的最大矩阵边长是512，
那么当bram足够时，创建一块支持1024x1024的bram，就不如创建
4块支持512x512的bram，因为后者可以提供更大的带宽
但其实如果计算图中有1024边长的矩阵，似乎也是创建4个512x512更快
但考虑到切块越小，总传输量越大的问题，所以不能按普通的512x512来处理
所谓切块越小总传输量越大，是因为切成小块之后，如果每一块传到片上之后只使用一次，
那就需要重复传输这一块。而切成大块之后，传上去之后相当于里面的每个小块都使用了很多次
所以将1024x1024切成512x512之后，为了不增加总传输量，就要求每一块传上去之后
需要重复使用，这就要求即便是切成512x512，仍要按照原来的1024x1024的数据去传，
即每次传输需要把原1024x1024切成的4个512x512方块传上去，而不能按行优先
传一行的4个512x512方块。这样子相当于还是计算1024x1024，同时能够获得更大的带宽
但这会带来一个问题，对于从1024x1024切出来的4块矩阵，需要计算A00xB00+A01xB10
对于仅有512的芯片来说，按顺序计算然后累加就可以。但在能够并行4个512x512的芯片上，
是可以同时计算A00xB00和A01xB01的，这就要求计算出来之后直接相加，所以实际上还是需要
1024的乘累加树。
所以综上所述，为了带宽，切块最大512。但乘累加树大小是和最大矩阵边长一样的。

### 在知道资源数量后，首先进行一次简单的分配
此时假设只进行方阵计算。目前保证AB的带宽为2的幂
对于矩阵A，设希望提供的带宽为$8n$，则：
当$n<=64$时，A和B各需要n块BRAM
从1开始遍历n
A，B各占用n块bram。A的数据量为$(8n)^2=64n^2Bytes$，则C的数据量为A的4倍，即$256n^2Bytes$。
需要的bram数量为$256n^2B/36kb=256n^2B/4.5kB=256n^2/4608=ceil(n^2/18)$块
当$n>64\ and\ n<=128$时，由于深度超过了单块bram的极限512，所以矩阵的每8列都需要2块bram。
即便把所有列合在一起申请也是一样，因为为了保证带宽，就没法利用每块里空闲的空间。
所以A和B各需要2n块BRAM。C不变

综上：
A和B各需要的bram数为：
$$ceil(n/64)\times n$$
C需要的bram数为：
$$ceil(n^2/18)$$
按照
$$A+B+C<=[0.9*Total]$$
找到第一次决定的n

#### 新的修改
当n<=64时，按照以上方法进行计算即可
当n>64时：
我们发现，当n从64变为65时，AB需要的bram数会从64变为130。这实际上导致了将近一半的bram空间是空着的，
同时也丢失了对65-128这段空间的搜索
为了更有效地利用空间，采取另一种方式：
对于超过64的部分，单独建立一块乘累加树，这样能够同时支持一块512*512, 以及一块小矩阵
如果能够容纳64 + 64，就能够同时支持两块512*512
所以按照前面所述，为了最大化利用带宽，我们实际上不需要在纵向上拼接Bram，
当bram的深度512全部利用起来了之后，就再开辟一块矩阵即可。
但如果带宽和计算单元足够，则乘累加树宽度需要与计算图中最大矩阵的宽度相同。
举例，如果片上能够容纳2块512x512，则支持的最大矩阵边长为512，且能并行2个512x512
如果能够容纳4块512x512，则支持1024，但仍需拆分为512传输计算
如果能够容纳512x512+256x256，则最大支持512x512，但只能同时计算1个512x512

所以对于类似512x512x4这种情况，如果计算单元足够，则增加并行
如果不够，就纵向垒起来，增加深度


然后根据n判断计算资源是否足够
如果不够，则从n至1遍历，直到找到合适的n

#### 新新的修改
举例，如果A和B均为512，则AB各需要64块bram，C需要256块bram
但事实上，一般的神经网络中很难出现512x512这么大的矩阵
比如resnet18最大只有128，resnet50最大只有256
像vgg这种网络才会有非常大的矩阵，比如vgg11有512，但vgg基本已经淘汰了
所以一般不会计算超大矩阵，
那么，既然不会计算512x512，也就不会有单个矩阵乘完之后直接把C的空间占满
而小矩阵很多时候是要累加的，也就会出现计算了多个小矩阵，结果占用空间仍旧
不是很大的情况，那么，是否可以把分给C的空间分出来一部分，用于提高带宽，
然后再加一组计算单元？
那么这个时候我就需要先切块，根据切块的结果再去分析能不能加计算单元

### 根据简单分配的结果，将计算图拆分为张量计算
现在，我们已经知道了片上支持的最大矩阵，可以按照最大矩阵切分矩阵了。
切分的原则为以下几点：
1. 尽量切大块，但不能超过片上支持的最大边长
2. 矩阵的相乘边(即A的横边和B的纵边)一定为2的幂
3. 矩阵的结果边(即A的纵边和B的横边)的长度要合适，保证填满bram的一行，不够的补0
切分之后，如果不存在片上支持的最大矩阵相乘，则可以酌情削减C的bram分配
#### 怎么削减？
找到一个计算流程，使得其尽可能多累加。使得C的峰值空间占用尽可能少
显然，如果张量计算中存在与芯片支持的最大矩阵相同的矩阵，则无法削减
如果不存在，则初步按照尽可能填满A和B的方式去传输数据和计算，计算C的峰值占用
然后根据C的峰值占用调整资源分配

### 资源的第二次分配
根据上一步计算出来的C的峰值占用，将C始终空闲的部分拿出去给其他部分使用：
如果AB带宽未达到512，则考虑加给AB，但仍需保证AB的带宽为2的幂
如果已经达到或者无法保证AB的带宽为2的幂，则单独成块，需保证新块的带宽为2的幂

如果发现C再多分出去一点，就能使新块的带宽再上一级，或是能使旧块的带宽再上一级，
则计算一下这种更激进的情况下的C的数值，然后和张量表达式生成器商量

否则资源分配到此结束

### 张量表达式的二次分配
在资源的二次分配给出的条件下，寻找新的计算方案
并评估新方案与旧方案相比的损失
根据每一次传输、内存拷贝、片上计算、启动DMA所需的总时间来估计
然后给出结论，是否同意C再多分出去一点

### 资源的三次分配
根据张量表达式二次分配的结果，进行最终分配

### 张量表达式的三次分配
根据资源分配最终结果，切分张量表达式