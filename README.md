# rtl_gen

## 关于张量表达式的生成和资源自动分配

### 首先根据计算图计算各层卷积大小
根据计算图中的数据，计算使用im2col后，各层卷积转换的矩阵大小
由于矩阵边长的限制，分块后单个矩阵的最大边长是有限的，
比如resnet18中，所需要计算的最大矩阵边长是512，
那么当bram足够时，创建一块支持1024x1024的bram，就不如创建
4块支持512x512的bram，因为后者可以提供更大的带宽
但其实如果计算图中有1024边长的矩阵，似乎也是创建4个512x512更快
但考虑到切块越小，总传输量越大的问题，所以不能按普通的512x512来处理
所谓切块越小总传输量越大，是因为切成小块之后，如果每一块传到片上之后只使用一次，
那就需要重复传输这一块。而切成大块之后，传上去之后相当于里面的每个小块都使用了很多次
所以将1024x1024切成512x512之后，为了不增加总传输量，就要求每一块传上去之后
需要重复使用，这就要求即便是切成512x512，仍要按照原来的1024x1024的数据去传，
即每次传输需要把原1024x1024切成的4个512x512方块传上去，而不能按行优先
传一行的4个512x512方块。这样子相当于还是计算1024x1024，同时能够获得更大的带宽
但这会带来一个问题，对于从1024x1024切出来的4块矩阵，需要计算A00xB00+A01xB10
对于仅有512的芯片来说，按顺序计算然后累加就可以。但在能够并行4个512x512的芯片上，
是可以同时计算A00xB00和A01xB01的，这就要求计算出来之后直接相加，所以实际上还是需要
1024的乘累加树。
所以综上所述，为了带宽，切块最大512。但乘累加树大小是和最大矩阵边长一样的。

### 在知道资源数量后，首先进行一次简单的分配
此时假设只进行方阵计算
对于矩阵A，设希望提供的带宽为$8n$，则：
当$n<=64$时，A和B各需要n块BRAM
从1开始遍历n
A，B各占用n块bram。A的数据量为$(8n)^2=64n^2Bytes$，则C的数据量为A的4倍，即$256n^2Bytes$。
需要的bram数量为$256n^2B/36kb=256n^2B/4.5kB=256n^2/4608=ceil(n^2/18)$块
当$n>64\ and\ n<=128$时，由于深度超过了单块bram的极限512，所以矩阵的每8列都需要2块bram。
即便把所有列合在一起申请也是一样，因为为了保证带宽，就没法利用每块里空闲的空间。
所以A和B各需要2n块BRAM。C不变

综上：
A和B各需要的bram数为：
$$ceil(n/64)\times n$$
C需要的bram数为：
$$ceil(n^2/18)$$
按照
$$A+B+C<=[0.9*Total]$$
找到第一次决定的n

#### 新的修改
当n<=64时，按照以上方法进行计算即可
当n>64时：
我们发现，当n从64变为65时，AB需要的bram数会从64变为130。这实际上导致了将近一半的bram空间是空着的，
同时也丢失了对65-128这段空间的搜索
为了更有效地利用空间，采取另一种方式：
对于超过64的部分，单独建立一块乘累加树，这样能够同时支持一块512*512, 以及一块小矩阵
如果能够容纳64 + 64，就能够同时支持两块512*512
所以按照前面所述，为了最大化利用带宽，我们实际上不需要在纵向上拼接Bram，
当bram的深度512全部利用起来了之后，就再开辟一块矩阵即可。
但如果带宽和计算单元足够，则乘累加树宽度需要与计算图中最大矩阵的宽度相同。
举例，如果片上能够容纳2块512x512，则支持的最大矩阵边长为512，切能并行2个512x512
如果能够容纳4块512x512，则支持1024，但仍需拆分为512传输计算
如果能够容纳512x512+256x256，则最大支持512x512，但只能同时计算1个512x512




然后根据n判断计算资源是否足够
如果不够，则从n至1遍历，知道找到合适的n

### 根据简单分配的结果，将计算图拆分为张量计算
